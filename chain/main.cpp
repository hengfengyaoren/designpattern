/*
 * 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理为止。
 *
 * 例子: 请假流程   1天以内经理  3天以内总监   3天以上老板
 *
 * 本质:
 * 分离算法，动态组合
 *
 * 要点：
 * 1 解耦请求放和处理方，请求方不知道请求是如何被处理，处理方的组成是由相互独立的子处理构成，子处理流程通过链表的方式连接，子处理请求可以按任意顺序组合。
 * 2 责任链请求强调请求最终由一个子处理流程处理；通过了各个子处理条件判断。
 * 3 责任链扩展就是功能链，功能链强调的是，一个请求依次经过由功能链中的子处理流程处理。
 * 4 充分体现了单一职责原则；将职责以及职责顺序进行抽象，那么职责变化可以任意扩展，同事职责顺序也可以任意扩展。
 *
 *
 * 优缺点:
 * 优点：
 * 1 降低耦合度，将请求的发送者和接受者解耦
 * 2 简化了对象，使得对象不需要知道链的结构
 * 3 增强给对象指派职责的灵活性，通过改变链内的成员或者调整他们的次序来动态改变职责
 * 4 增加新的具体处理者很方便，无需修改原有代码，只需要在客户端重新建链即可
 * 缺点：
 * 1 没有明确的接受者，无法保证请求一定会被处理
 * 2 对于长的职责链来说，涉及到很多对象的时候，性能可能会受到一定的影响，而且不不利用代码调试。
 * 3 建链不当，可能造成死循环。
 *
 * 适用场景:
 * 1 有多个对象可以处理同一请求，具体哪个对象处理由运行时刻自动确定。客户端只负责提交请求，无需关系请求的处理对象是谁以及是如何处理的
 * 2 在不明确指定接受者的条件下，向多个对象中一个提交一个请求
 * 3 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。
 *
 *
 */

// main.cpp
#include "concrete_handler.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    IHandler *manager = new Manager();
    IHandler *director = new Director();
    IHandler *ceo = new CEO();

    // 职责链：经理 -> 总监 -> 总裁
    manager->SetSuccessor(director);
    director->SetSuccessor(ceo);

    manager->HandlerRequest(1);
    manager->HandlerRequest(2);
    manager->HandlerRequest(5);
    manager->HandlerRequest(10);

    SAFE_DELETE(manager);
    SAFE_DELETE(director);
    SAFE_DELETE(ceo);

    getchar();

    return 0;
}



