/*
 * 定义一个操作算法的骨架，而将一些步粗延迟到子类中。 Template Method使得子类可以不改变某个算法的结构即可重定义该算法的某些特定步骤。
 *
 * 例子: 招聘流程
 *
 * 设计原则:
 * 单一职责原则
 * 接口分离原则
 * 依赖倒置原则
 *
 * 本质:
 * 通过固定算法骨架来约束子类的行为；
 *
 * 要点：
 * 非常常用的设计模式，子类可以复写父类的子流程，使父类的大流程更丰富
 * 反向控制流程的定型应用
 * 父类 protected保护子类需要腹泻子流程，这样子类的子流程智能父类调用
 * 充分体现了依赖倒置原则
 *
 *
 * 优缺点:
 * 优点：1 父类形式化定义一个算法，由子类实现细节处理，子类详细处理算法时候并不会改变算法中的执行顺序。
 * 	2 代码复用技术，类库设计尤为重要，提取公共行为再父类，子类来实现不同的行为。
 * 	3 可实现反向控制结构，子类覆盖父类的钩子方法来决定某一特定流程是否执行
 * 	4 可以子类覆盖父类的基本方法，不同子类不同的实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则
 * 缺点：
 * 每个基本方法的不同实现提供一个子类，如果父类可变的基本方法太多，将会倒置类个数增加，系统根据庞大，设计也复杂。
 *
 *
 * 适用场景:
 * 1 复杂算分进行分割，将算法固定不变得部分设计为魔板方法和父类具体方法，而一些可变的细节由子类实现
 * 2 歌子类中公共行为提取集中到一个公共父类中
 * 3 需要通过子类来决定父类算法某个流程是否执行，实现子类对父类的方向控制
 *
 */

#include "concrete_class.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) {if(p){delete(p); (p) = NULL;}}
#endif

int main(){
	std::cout << " **************alibaba********************" << std::endl;
	//阿里校招
	Company *alibaba = new Alibaba();
	alibaba->Recruit();	

	std::cout << " **************tencent********************" << std::endl;
	//腾讯校招
	Company *tencent = new Tencent();
        tencent->Recruit();	

	SAFE_DELETE(tencent);
	SAFE_DELETE(alibaba);

	getchar();

	return 0;

}


